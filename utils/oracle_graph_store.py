"""
Oracle图数据存储类
"""

import oracledb
import logging
from datetime import datetime
import os
from dotenv import load_dotenv
from typing import List, Dict, Any, Optional
import json

# 加载环境变量
load_dotenv()
logger = logging.getLogger(__name__)

class OracleGraphStore:
    def __init__(self):
        """初始化图数据存储"""
        self.pool = None
        self.init_connection_pool()
        self.init_graph()

    def init_connection_pool(self):
        self.user = os.getenv("ORACLE_USER")
        self.password = os.getenv("ORACLE_PASSWORD")
        self.dsn = os.getenv("ORACLE_DSN")
        self.connection = None
        
        if not all([self.user, self.password, self.dsn]):
            raise ValueError("请在.env文件中设置ORACLE_USER, ORACLE_PASSWORD和ORACLE_DSN")
        
        try:
            self.connection = oracledb.connect(
                user=self.user,
                password=self.password,
                dsn=self.dsn
            )
            # 初始化表结构
            self.init_schema()
            logger.info("初始化OracleGraphStore成功")
        except Exception as e:
            logger.error(f"初始化OracleGraphStore失败: {str(e)}")
            raise

    def init_schema(self):
        """初始化数据库表结构"""
        try:
            cursor = self.connection.cursor()
            
            # 检查表是否存在的SQL
            check_table_sql = """
                SELECT table_name 
                FROM user_tables 
                WHERE table_name IN ('MEDICAL_ENTITIES', 'MEDICAL_RELATIONS')
            """
            cursor.execute(check_table_sql)
            existing_tables = {row[0].upper() for row in cursor}
            
            # 检查表结构
            if 'MEDICAL_ENTITIES' in existing_tables:
                # 检查表的列结构
                check_columns_sql = """
                    SELECT column_name 
                    FROM user_tab_columns 
                    WHERE table_name = 'MEDICAL_ENTITIES'
                """
                cursor.execute(check_columns_sql)
                existing_columns = {row[0].upper() for row in cursor}
                
                # 如果表结构不完整，删除表并重新创建
                required_columns = {'ID', 'ENTITY_TYPE', 'ENTITY_NAME', 'ENTITY_VALUE', 'DOC_REF', 'CREATED_AT'}
                if not required_columns.issubset(existing_columns):
                    cursor.execute("DROP TABLE MEDICAL_ENTITIES CASCADE CONSTRAINTS")
                    existing_tables.remove('MEDICAL_ENTITIES')
                    logger.info("删除不完整的 MEDICAL_ENTITIES 表")
            
            if 'MEDICAL_RELATIONS' in existing_tables:
                # 检查表的列结构
                check_columns_sql = """
                    SELECT column_name 
                    FROM user_tab_columns 
                    WHERE table_name = 'MEDICAL_RELATIONS'
                """
                cursor.execute(check_columns_sql)
                existing_columns = {row[0].upper() for row in cursor}
                
                # 如果表结构不完整，删除表并重新创建
                required_columns = {'ID', 'SOURCE_ID', 'TARGET_ID', 'RELATION_TYPE', 'RELATION_VALUE', 'DOC_REF', 'CREATED_AT'}
                if not required_columns.issubset(existing_columns):
                    cursor.execute("DROP TABLE MEDICAL_RELATIONS")
                    existing_tables.remove('MEDICAL_RELATIONS')
                    logger.info("删除不完整的 MEDICAL_RELATIONS 表")
            
            # 创建 MEDICAL_ENTITIES 表
            if 'MEDICAL_ENTITIES' not in existing_tables:
                create_entities_table = """
                    CREATE TABLE MEDICAL_ENTITIES (
                        ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        ENTITY_TYPE VARCHAR2(100) NOT NULL,
                        ENTITY_NAME VARCHAR2(1000) NOT NULL,
                        ENTITY_VALUE CLOB,
                        DOC_REF VARCHAR2(1000),
                        CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """
                cursor.execute(create_entities_table)
                logger.info("MEDICAL_ENTITIES 表创建成功")
            else:
                logger.info("MEDICAL_ENTITIES 表已存在且结构完整")
            
            # 创建 MEDICAL_RELATIONS 表
            if 'MEDICAL_RELATIONS' not in existing_tables:
                create_relations_table = """
                    CREATE TABLE MEDICAL_RELATIONS (
                        ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        SOURCE_ID NUMBER,
                        TARGET_ID NUMBER,
                        RELATION_TYPE VARCHAR2(100) NOT NULL,
                        RELATION_VALUE CLOB,
                        DOC_REF VARCHAR2(1000),
                        CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        CONSTRAINT FK_SOURCE FOREIGN KEY (SOURCE_ID) REFERENCES MEDICAL_ENTITIES(ID),
                        CONSTRAINT FK_TARGET FOREIGN KEY (TARGET_ID) REFERENCES MEDICAL_ENTITIES(ID)
                    )
                """
                cursor.execute(create_relations_table)
                logger.info("MEDICAL_RELATIONS 表创建成功")
            else:
                logger.info("MEDICAL_RELATIONS 表已存在且结构完整")
            
            # 提交事务
            self.connection.commit()
            
        except Exception as e:
            logger.error(f"初始化表结构失败: {str(e)}")
            self.connection.rollback()
            raise

    def init_graph(self):
        """初始化属性图"""
        try:
            # 检查是否支持属性图功能
            check_pg_support_sql = """
            SELECT COUNT(*) 
            FROM ALL_OBJECTS 
            WHERE OBJECT_NAME = 'USER_PG_GRAPHS'
            """
            result = self.execute_sql(check_pg_support_sql)
            pg_supported = result[0]['count(*)'] > 0 if result else False

            if not pg_supported:
                logger.warning("当前数据库未启用属性图功能，跳过属性图初始化")
                return

            # 删除已存在的图
            try:
                drop_graph_sql = """
                DROP PROPERTY GRAPH MEDICAL_KG FORCE
                """
                self.execute_sql(drop_graph_sql)
                logger.info("已删除现有的 MEDICAL_KG 图")
            except Exception as e:
                logger.debug(f"删除图时出错(可能是图不存在): {str(e)}")

            # 创建新图
            create_graph_sql = """
            CREATE PROPERTY GRAPH MEDICAL_KG
                VERTEX TABLES (
                    MEDICAL_ENTITIES
                    KEY (ID)
                    PROPERTIES (ENTITY_TYPE, ENTITY_NAME, ENTITY_VALUE)
                )
                EDGE TABLES (
                    MEDICAL_RELATIONS
                    KEY (ID)
                    SOURCE KEY (SOURCE_ID) REFERENCES MEDICAL_ENTITIES(ID)
                    DESTINATION KEY (TARGET_ID) REFERENCES MEDICAL_ENTITIES(ID)
                    PROPERTIES (RELATION_TYPE, RELATION_VALUE)
                )
            """
            
            # 执行创建图的SQL
            self.execute_sql(create_graph_sql)
            logger.info("成功创建属性图 MEDICAL_KG")

            # 验证图是否创建成功
            check_graph_sql = """
            SELECT COUNT(*) 
            FROM USER_PG_GRAPHS 
            WHERE GRAPH_NAME = 'MEDICAL_KG'
            """
            result = self.execute_sql(check_graph_sql)
            if not result or result[0]['count(*)'] == 0:
                raise Exception("图创建后未找到,创建可能失败")

        except Exception as e:
            logger.error(f"初始化属性图失败: {str(e)}")
            raise  # 抛出异常而不是继续执行

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.connection:
            self.connection.close()
            logger.info("关闭OracleGraphStore连接")

    def execute_sql(self, query: str, params: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """
        执行SQL查询
        
        Args:
            query (str): SQL查询语句
            params (Optional[Dict]): 查询参数
            
        Returns:
            List[Dict[str, Any]]: 查询结果列表，如果是 INSERT/UPDATE/DELETE 语句则返回空列表
        """
        try:
            cursor = self.connection.cursor()
            
            # 记录原始查询
            logger.info("执行SQL查询: %s", query)
            if params:
                logger.info("参数: %s", params)
            
            # 执行SQL查询
            cursor.execute(query, params or {})
            
            # 如果是 SELECT 语句，返回结果集
            if cursor.description:
                # 获取列名
                columns = [col[0].lower() for col in cursor.description]
                
                # 处理结果
                results = []
                for row in cursor:
                    result = {}
                    for i, value in enumerate(row):
                        # 处理LOB对象
                        if isinstance(value, oracledb.LOB):
                            try:
                                result[columns[i]] = json.loads(value.read())
                            except json.JSONDecodeError:
                                result[columns[i]] = value.read()
                        else:
                            result[columns[i]] = value if value is not None else ''
                    results.append(result)
                
                return results
            
            # 如果是 INSERT/UPDATE/DELETE 语句，返回空列表
            return []
                
        except Exception as e:
            logger.error(f"执行SQL查询失败: {str(e)}")
            raise

    def execute_pgql(self, query: str, params: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """
        执行PGQL查询
        
        Args:
            query (str): PGQL查询语句
            params (Optional[Dict]): 查询参数
            
        Returns:
            List[Dict[str, Any]]: 查询结果列表
        """
        try:
            # 首先检查是否支持属性图功能
            check_pg_support_sql = """
            SELECT COUNT(*) 
            FROM ALL_OBJECTS 
            WHERE OBJECT_NAME = 'USER_PG_GRAPHS'
            """
            result = self.execute_sql(check_pg_support_sql)
            pg_supported = result[0]['count(*)'] > 0 if result else False

            if not pg_supported:
                logger.warning("当前数据库未启用属性图功能，无法执行PGQL查询")
                return []

            # 检查图是否存在
            check_graph_sql = """
            SELECT COUNT(*) 
            FROM USER_PG_GRAPHS 
            WHERE GRAPH_NAME = 'MEDICAL_KG'
            """
            result = self.execute_sql(check_graph_sql)
            graph_exists = result[0]['count(*)'] > 0 if result else False

            if not graph_exists:
                logger.warning("属性图 MEDICAL_KG 不存在，无法执行PGQL查询")
                return []
            
            # 记录查询
            logger.info("执行PGQL查询: %s", query)
            if params:
                logger.info("参数: %s", params)
            
            # 执行查询
            cursor = self.connection.cursor()
            cursor.execute(query, params or {})
            
            # 获取结果
            if cursor.description:
                columns = [col[0].lower() for col in cursor.description]
                results = []
                for row in cursor:
                    result = {}
                    for i, value in enumerate(row):
                        if isinstance(value, oracledb.LOB):
                            try:
                                result[columns[i]] = json.loads(value.read())
                            except json.JSONDecodeError:
                                result[columns[i]] = value.read()
                        else:
                            result[columns[i]] = value if value is not None else ''
                    results.append(result)
                return results
            
            return []
        
        except Exception as e:
            logger.error(f"执行PGQL查询失败: {str(e)}")
            return []

    def get_patients(self) -> List[Dict[str, Any]]:
        """获取所有患者列表"""
        try:
            # 获取所有患者实体
            sql = """
                SELECT 
                    e.ENTITY_NAME,
                    e.DOC_REF,
                    e.ENTITY_VALUE
                FROM MEDICAL_ENTITIES e
                WHERE e.ENTITY_TYPE = '患者'
            """
            logger.info(f"执行患者查询SQL: {sql}")
            results = self.execute_sql(sql)
            
            if not results:
                logger.info("没有找到任何患者数据")
                return []
            
            processed_results = []
            for row in results:
                try:
                    # 解析患者信息
                    entity_value = row['entity_value']
                    if isinstance(entity_value, str):
                        patient_info = json.loads(entity_value)
                    else:
                        patient_info = entity_value
                    
                    logger.info(f"解析的患者信息: {patient_info}")
                    
                    # 构建患者数据
                    patient_data = {
                        "姓名": patient_info.get("患者姓名", row['entity_name']),
                        "文档": row['doc_ref'],
                        "基本信息": {
                            "姓名": patient_info.get("患者姓名", "未知"),
                            "性别": patient_info.get("性别", "未知"),
                            "年龄": patient_info.get("年龄", "未知"),
                            "入院日期": patient_info.get("入院日期", "未知"),
                            "出院日期": patient_info.get("出院日期", "未知")
                        },
                        "主诉": patient_info.get("主诉", "未知"),
                        "现病史": patient_info.get("现病史", []),
                        "入院诊断": patient_info.get("入院诊断", []),
                        "出院诊断": patient_info.get("出院诊断", []),
                        "生命体征": patient_info.get("生命体征", {}),
                        "生化指标": patient_info.get("生化指标", {}),
                        "诊疗经过": patient_info.get("诊疗经过", ""),
                        "出院医嘱": patient_info.get("出院医嘱", []),
                        "metadata": patient_info.get("metadata", {})
                    }
                    
                    logger.info(f"处理后的患者数据: {patient_data}")
                    processed_results.append(patient_data)
                    
                except json.JSONDecodeError as e:
                    logger.error(f"解析患者信息失败: {str(e)}, 原始数据: {row['entity_value']}")
                    # 即使解析失败，也添加基本信息
                    processed_results.append({
                        "姓名": row['entity_name'],
                        "文档": row['doc_ref'],
                        "基本信息": {},
                        "主诉": "未知",
                        "现病史": [],
                        "入院诊断": [],
                        "出院诊断": [],
                        "生命体征": {},
                        "生化指标": {},
                        "诊疗经过": "",
                        "出院医嘱": [],
                        "metadata": {}
                    })
                except Exception as e:
                    logger.error(f"处理患者数据时出错: {str(e)}, 跳过此条记录")
                    continue
            
            logger.info(f"最终返回的患者数量: {len(processed_results)}")
            return processed_results
                
        except Exception as e:
            logger.error(f"获取患者列表失败: {str(e)}")
            return []

    def get_all_patients(self) -> List[Dict[str, Any]]:
        """获取所有患者列表（get_patients 的别名）"""
        return self.get_patients()

    def get_patient_info(self, patient_name: str) -> Dict[str, Any]:
        """获取指定患者的详细信息"""
        try:
            # 获取患者实体信息
            sql = """
                SELECT 
                    e.ENTITY_NAME,
                    e.DOC_REF,
                    e.ENTITY_VALUE
                FROM MEDICAL_ENTITIES e
                WHERE e.ENTITY_TYPE = '患者'
                AND e.ENTITY_NAME = :1
            """
            logger.info(f"执行患者查询SQL: {sql}")
            results = self.execute_sql(sql, [patient_name])
            
            if not results:
                logger.info(f"未找到患者: {patient_name}")
                return {}
            
            row = results[0]
            try:
                # 解析患者信息
                entity_value = row['entity_value']
                if isinstance(entity_value, str):
                    patient_info = json.loads(entity_value)
                else:
                    patient_info = entity_value
                
                logger.info(f"解析的患者信息: {patient_info}")
                
                # 返回完整的患者信息
                return {
                    "姓名": row['entity_name'],
                    "文档": row['doc_ref'],
                    **patient_info  # 展开完整的患者信息
                }
                
            except json.JSONDecodeError as e:
                logger.error(f"解析患者信息失败: {str(e)}, 原始数据: {row['entity_value']}")
                return {
                    "姓名": row['entity_name'],
                    "文档": row['doc_ref']
                }
            except Exception as e:
                logger.error(f"处理患者数据时出错: {str(e)}")
                return {
                    "姓名": row['entity_name'],
                    "文档": row['doc_ref']
                }
                
        except Exception as e:
            logger.error(f"获取患者信息失败: {str(e)}")
            return {}

    def delete_document_data(self, doc_ref: str) -> None:
        """
        删除指定文档的所有图数据
        
        Args:
            doc_ref (str): 文档引用标识
        """
        try:
            # 删除实体和关系数据
            delete_entities_sql = """
                DELETE FROM MEDICAL_ENTITIES
                WHERE DOC_REF = :1
            """
            delete_relations_sql = """
                DELETE FROM MEDICAL_RELATIONS
                WHERE DOC_REF = :1
            """
            
            logger.info(f"删除文档 {doc_ref} 的图数据")
            
            # 执行删除操作
            self.execute_sql(delete_entities_sql, [doc_ref])
            self.execute_sql(delete_relations_sql, [doc_ref])
            
            # 提交事务
            self.connection.commit()
            
            logger.info(f"成功删除文档 {doc_ref} 的图数据")
            
        except Exception as e:
            logger.error(f"删除文档图数据失败: {str(e)}")
            # 回滚事务
            self.connection.rollback()
            raise

    def store_medical_data(self, data: Dict[str, Any], doc_ref: str) -> None:
        """
        存储医疗数据到图数据库
        
        Args:
            data (Dict[str, Any]): 医疗数据字典
            doc_ref (str): 文档引用标识
        """
        try:
            cursor = self.connection.cursor()
            
            # 存储患者实体
            patient_sql = """
                DECLARE
                    v_id NUMBER;
                BEGIN
                    INSERT INTO MEDICAL_ENTITIES (
                        ENTITY_TYPE, ENTITY_NAME, ENTITY_VALUE, DOC_REF
                    ) VALUES (
                        '患者', :name, :value, :doc_ref
                    ) RETURNING ID INTO v_id;
                    :id := v_id;
                END;
            """
            
            # 获取患者姓名
            patient_name = data.get("患者姓名", "未知患者")
            patient_id = cursor.var(int)
            
            # 执行插入
            cursor.execute(patient_sql, {
                'name': patient_name,
                'value': json.dumps(data, ensure_ascii=False),
                'doc_ref': doc_ref,
                'id': patient_id
            })
            
            # 存储主诉与诊断
            for diagnosis in data.get("主诉与诊断", []):
                diagnosis_sql = """
                    DECLARE
                        v_id NUMBER;
                    BEGIN
                        INSERT INTO MEDICAL_ENTITIES (
                            ENTITY_TYPE, ENTITY_NAME, ENTITY_VALUE, DOC_REF
                        ) VALUES (
                            '诊断', :name, :value, :doc_ref
                        ) RETURNING ID INTO v_id;
                        :id := v_id;
                    END;
                """
                diagnosis_id = cursor.var(int)
                cursor.execute(diagnosis_sql, {
                    'name': diagnosis.get("类型", "未知类型"),
                    'value': json.dumps(diagnosis, ensure_ascii=False),
                    'doc_ref': doc_ref,
                    'id': diagnosis_id
                })
                
                # 创建关系
                relation_sql = """
                    INSERT INTO MEDICAL_RELATIONS (
                        SOURCE_ID, TARGET_ID, RELATION_TYPE, DOC_REF
                    ) VALUES (
                        :source_id, :target_id, '诊断', :doc_ref
                    )
                """
                cursor.execute(relation_sql, {
                    'source_id': patient_id.getvalue(),
                    'target_id': diagnosis_id.getvalue(),
                    'doc_ref': doc_ref
                })
            
            # 存储现病史
            for history in data.get("现病史", []):
                history_sql = """
                    DECLARE
                        v_id NUMBER;
                    BEGIN
                        INSERT INTO MEDICAL_ENTITIES (
                            ENTITY_TYPE, ENTITY_NAME, ENTITY_VALUE, DOC_REF
                        ) VALUES (
                            '现病史', :name, :value, :doc_ref
                        ) RETURNING ID INTO v_id;
                        :id := v_id;
                    END;
                """
                history_id = cursor.var(int)
                cursor.execute(history_sql, {
                    'name': history.get("症状", "未知症状"),
                    'value': json.dumps(history, ensure_ascii=False),
                    'doc_ref': doc_ref,
                    'id': history_id
                })
                
                # 创建关系
                relation_sql = """
                    INSERT INTO MEDICAL_RELATIONS (
                        SOURCE_ID, TARGET_ID, RELATION_TYPE, DOC_REF
                    ) VALUES (
                        :source_id, :target_id, '现病史', :doc_ref
                    )
                """
                cursor.execute(relation_sql, {
                    'source_id': patient_id.getvalue(),
                    'target_id': history_id.getvalue(),
                    'doc_ref': doc_ref
                })
            
            # 存储生命体征
            for vital in data.get("生命体征", []):
                vital_sql = """
                    DECLARE
                        v_id NUMBER;
                    BEGIN
                        INSERT INTO MEDICAL_ENTITIES (
                            ENTITY_TYPE, ENTITY_NAME, ENTITY_VALUE, DOC_REF
                        ) VALUES (
                            '生命体征', :name, :value, :doc_ref
                        ) RETURNING ID INTO v_id;
                        :id := v_id;
                    END;
                """
                vital_id = cursor.var(int)
                cursor.execute(vital_sql, {
                    'name': vital.get("指标", "未知指标"),
                    'value': json.dumps(vital, ensure_ascii=False),
                    'doc_ref': doc_ref,
                    'id': vital_id
                })
                
                # 创建关系
                relation_sql = """
                    INSERT INTO MEDICAL_RELATIONS (
                        SOURCE_ID, TARGET_ID, RELATION_TYPE, DOC_REF
                    ) VALUES (
                        :source_id, :target_id, '生命体征', :doc_ref
                    )
                """
                cursor.execute(relation_sql, {
                    'source_id': patient_id.getvalue(),
                    'target_id': vital_id.getvalue(),
                    'doc_ref': doc_ref
                })
            
            # 存储生化指标
            for lab in data.get("生化指标", []):
                lab_sql = """
                    DECLARE
                        v_id NUMBER;
                    BEGIN
                        INSERT INTO MEDICAL_ENTITIES (
                            ENTITY_TYPE, ENTITY_NAME, ENTITY_VALUE, DOC_REF
                        ) VALUES (
                            '生化指标', :name, :value, :doc_ref
                        ) RETURNING ID INTO v_id;
                        :id := v_id;
                    END;
                """
                lab_id = cursor.var(int)
                cursor.execute(lab_sql, {
                    'name': lab.get("项目", "未知项目"),
                    'value': json.dumps(lab, ensure_ascii=False),
                    'doc_ref': doc_ref,
                    'id': lab_id
                })
                
                # 创建关系
                relation_sql = """
                    INSERT INTO MEDICAL_RELATIONS (
                        SOURCE_ID, TARGET_ID, RELATION_TYPE, DOC_REF
                    ) VALUES (
                        :source_id, :target_id, '生化指标', :doc_ref
                    )
                """
                cursor.execute(relation_sql, {
                    'source_id': patient_id.getvalue(),
                    'target_id': lab_id.getvalue(),
                    'doc_ref': doc_ref
                })
            
            # 提交事务
            self.connection.commit()
            logger.info(f"成功存储文档 {doc_ref} 的图数据")
            
        except Exception as e:
            logger.error(f"存储图数据失败: {str(e)}")
            self.connection.rollback()
            raise